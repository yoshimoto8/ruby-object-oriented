## 依存関係を管理んする

オブジェクト同士の相互作用をなくすことはできない。つまりメッセージを送り合わなければならない。なぜなら一つのオブジェクトですべてのデータやメソットを知ることはできないから。

オブジェクトに望まれる振る舞いは、

1. オブジェクト自身が知っている
2. 継承している
3. そのメッセージを理解する他のオブジェクトを知っている

1番は前の章で扱った。今回は３番目について説明される

### 共同作業をする問題点

共同作業をすることは強力だが、あるオブジェクトは他のオブジェクトを知っていなければならないので依存関係を作り出してしまう。

慎重に対応しないと、依存関係がアプリケーションを苦しめてくる。

不必要な依存関係は「合理性」を失う。「合理性とは何か？」

- 合理的(Reasonable): どんな変更があっても、かかるコストは変更がもたらす利益にふさわしい。



### 依存関係とはなんなのか？

２章のコードで４つの依存関係がある

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog       = cog
    @rim       = rim
    @tire      = tire
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end

  def ratio
    chainring / cog.to_f
  end
# ...
end

class Wheel
  attr_reader :rim, :tire
  def initialize(rim, tire)
    @rim       = rim
    @tire      = tire
  end

  def diameter
    rim + (tire * 2)
  end
# ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
```

1. 他のクラスの名前: Gearは、wheelという名前のクラスが存在していることを予想している
2. self以外のどこかに送ろうとするメッセージの名前は:Gearは、Wheelのインスタンスがdiameterに応答することを予想している
3. メッセージが要求する引数：Gearは、Wheel.newにrimとtireが必要なことを知っている
4. それら引数に順番:Gearは、wheel.newの最初の引数がrimで、２番目がtireである必要があることを知っている

### オブジェクトの注入(object injection)

`他のクラスに、クラス名そのもので参照しているところは、結合を生み出す主要な場所の１つです。`

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog       = cog
    @rim       = rim
    @tire      = tire
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end

  def ratio
    chainring / cog.to_f
  end
# ...
end

class Wheel
  attr_reader :rim, :tire
  def initialize(rim, tire)
    @rim       = rim
    @tire      = tire
  end

  def diameter
    rim + (tire * 2)
  end
# ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
```

↑ のコードの問題は wheel の名前に変更があった場合、Gear の gear_inches メソットも変更する必要があるということ。

しかし名前の変更への対応は比較的小さな問題。

gear から wheel への参照が、gear_inches メソット内という深いところでハードコーディングされている時、それは明示的に「wheel インスタンスのギアインチしか  計算する意思はない」と宣言していることにほかならなない。

ディスクやシリンダのメソットがあった場合

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog       = cog
    @rim       = rim
    @tire      = tire
  end

  def desc
  end

  def Cylinder
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end
# ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
```

diameterの値を知りたくてもGearがwheelに結合しているために知ることができない。もちろん新しくインスタンスを作れば計算することはできるが・・・・

Gearが知っていなければならないのはただのオブジェクト

このテクニックがオブジェクトの注入(object injection)

## 依存を隔離する

もし不必要な依存を除去することができないのであれば、クラス内で隔離するべき。

### インスタンス変数の作成を分離する

`分離するその１`

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel)
    @chainring = chainring
    @cog       = cog
    @wheel     = wheel
  end

  def gear_inches
    ratio * wheel.diameter
  end
# ...
end

Gear.new(52, 11, Wheel.new(26, 1.5)).gear_inches
```

Gearのgear_ichesメソットからGearのinitializeメソットに写している。こうすることでgear_inchesメソットは綺麗になり、依存はinitilizeメソットで公開されることになる。

ここで注意するべきことは、Gearクラスが呼ばれるときにwheelも無条件でつくられたしまうことである。

`分離する例その２`

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire, :wheel
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog       = cog
    @rim       = rim
    @tire      = tire
  end

  def gear_inches
    ratio * wheel.diameter
  end

  def wheel
    @wheel ||= Wheel.new(rim, tire)
  end
```

この例ではwheelの作成を隔離し、独自に明示的に定義したwheelメソット内で行うようにしている。この新しいメソッドは`分離する例その１`と違って必要になるときまでWheelのインスタンスを作成しない。

### 脆い外部メッセージを隔離する

```ruby
def gear_inches
  ratio * wheel.diameter
end
```

このコードではなんの問題もないが、もし複雑な処理を加えたときに問題が発生する

```ruby
def gear_inches
  #... a few lines of scary math
  foo = some_intermediate_result * wheel.diameter
  #... more lines of scary math
end
```

`gear_inches`メソットを変更せざるを得ない可能性を減らすためにできることは、次のコードに示すとおり、外部的な依存を取り除き専用メソットないにカプセル化することです。

```ruby
def gear_inches
  #... a few lines of scary math
  foo = some_intermediate_result * diameter
  #... more lines of scary math
end

def diameter
  wheel.diameter
end
```

このテクニックが必要になるのは、「メッセージ」への参照がクラスに埋め込まれていて、さらにそのメッセージが変わる可能性が高い時。

## 引数の順番への依存を取り除く

引数が必要なメッセージを送るとき、送り手側としては、それら引数についての知識を持たせないといけません。この依存は避けられないもの。

下の例でも`正しい順番で`かつ`正しい数で`渡さなければならない。

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel)
    @chainring = chainring
    @cog       = cog
    @wheel     = wheel
  end
  ...
end

Gear.new(
  52,
  11,
  Wheel.new(26, 1.5)).gear_inches
```

### 初期化の際の引数にハッシュを使う

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(args)
    @chainring = args[:chainring]
    @cog       = args[:cog]
    @wheel     = args[:wheel]
  end
  ...
end

Gear.new(
  :chainring => 52,
  :cog       => 11,
  :wheel     => Wheel.new(26, 1.5)).gear_inches
```

このテクニックにはいくつかメリットが存在する。メリットその１は、引数の順番に対する依存がすべて取り除かれている点。

メリットその２は、ハッシュ内の「キー」名が引数に関する明示的なドキュメントとなっている点。


